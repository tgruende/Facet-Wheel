<!DOCTYPE html>
<meta charset="utf-8">
<html>
    <head>
        <title>GROUPS</title>
    </head>

<style>

#title {
	position:absolute;
	top:0px;
	left:230px;
	width:780px;
	height: 40px; 
}

#info {
	position:absolute;
	top:0px;
	left:1010px;
	width:700px;
	height: 40px; 
}

#controls {
	position:absolute;
	top:40px;
	left:10px;
	width:220px;
	height: 650px; 
}

#network_viz {
	position:absolute;
	top:40px;
	left:230px;
	width:780px;
	height: 650px; 
}

#time_viz {
	position:absolute;
	top:690px;
	left:10px;
	width:1000px;
	height: 250px; 
}

#space_viz {
	position:absolute;
	top:40px;
	left:1010px;
	width:700px;
	height: 900px; 
}

.text-mitte {
    text-anchor: middle;
}

.bar {
  fill: red;
  fill-opacity: .5;
  stroke: #fff;
  stroke-width: 0px;
}

.bar :hover {
    fill-opacity: 1;
}


.axis {
	font: 10px sans-serif;
}

.axis path,
.axis line {
	fill: none;
  stroke: #000;
  stroke-width: 1px;
	shape-rendering: crispEdges;
}

.grid line {
  stroke: lightgrey;
  stroke-opacity: 0.7;
  shape-rendering: crispEdges;
}

.grid path {
  stroke-width: 0;
}

.label {
  font: 10px sans-serif;	
}

#grouptime {
	 font-family: sans-serif;
    font-size: 12px;
}


.legend circle {
  fill: none;
  stroke: black;
}

.legend line {
  fill: none;
  stroke: black;
  stroke-width: 0.5px;
}

.legend text {
  fill: black;
  font: 10px sans-serif;
  text-anchor: left;
}

.bubble {
  fill: red;
  fill-opacity: .5;
  stroke: #fff;
  stroke-width: 0.5px;
}

.bubble :hover {
  stroke: #000;
}



</style>

<body>
    <div id=title>
        <svg height="40" width="780">
            <text x="50%" y="50%" dominant-baseline="middle" class="text-mitte" style="fill: black;" font-family="sans-serif" font-size="24px" fill="black">Groups of Members of Parliament on X</text>
        </svg>
    </div>

    <div id=info>
        <svg height="40" width="700">
            <text x="50%" y="50%" dominant-baseline="middle" class="text-mitte" style="fill: black;" font-family="sans-serif" font-size="12px" fill="black">data sources: X (Twitter), Deutscher Bundestag; data from 01.01.2017 - 31.12.2017</text>
       </svg>
    </div>
    
    <div id="network_viz"></div>
    <div id="controls"></div>
    <div id="time_viz"></div>
    <div id="space_viz"></div>



</body>
    
<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo-projection/2.7.0/d3-geo-projection.min.js"></script>


<script>


// Read data <script type="text/javascript" src="https://d3js.org/d3.v4.min.js">
// d3.json("RKI_COVID19_data_2020-05-25_groups.json", 

// Read data 

d3.queue()
  .defer(d3.json, "mdb-bundestag_TWITTER_groups_ioui.json")  // Gruppen     "mdb-bundestag-tweets_TWITTER_klimaschutz_groups_jaccard.json"     "mdb-bundestag_TWITTER_groups_jaccard.json"     "RKI_COVID19_data_2021-11-10_groups.json"
  .defer(d3.json, "deu_wahlkreise_simp.geojson")  // Map    "deu_wahlkreise_simp.geojson"     "deu_simp.geojson"
  .await(main);





// Funktionen
function main(error, dataGroups, dataGeo) {
    createControls(dataGroups, dataGeo, "#controls");
    createNetworkViz(dataGroups, dataGeo, "#network_viz");
    createTimeViz(dataGroups, "#time_viz");
    createSpaceViz(dataGroups, dataGeo, "#space_viz");

}



function rotate_point(pointX, pointY, originX, originY, angle) {
    angle = angle * Math.PI / 180.0;
    return {
        X: Math.cos(angle) * (pointX-originX) - Math.sin(angle) * (pointY-originY) + originX,
        Y: Math.sin(angle) * (pointX-originX) + Math.cos(angle) * (pointY-originY) + originY
    };
}

function setDiameter(width, height) {
    if (width > height) {
        return height * 0.6;
    } else {
        return width * 0.6;
    }
}


function createControls(dataGroups, dataGeo, targetSVG) {
// Erstellung Text in controls

// SVG
var svg = d3.select(targetSVG)
        .append("svg")
        .attr("width", 220)
        .attr("height", 650)

svg.append("g")
        .attr("class", "filterText")
        .attr("transform", "translate(" + 0 + "," + 40 + ")")

  // Überschrift Auswahl Gruppengrad
  svg.select(".filterText")
  .append("text")
    .attr("x", 25)
    .attr("y", -30)
    .attr("font-size", "14px")
    .attr("font-family", "sans-serif")
    .html("Degree of Combination");

    // Überschrift Auswahl Gruppengröße
    svg.select(".filterText")
    .append("text")
        .attr("x", 25)
        .attr("y", 20)
        .attr("font-size", "14px")
        .attr("font-family", "sans-serif")
        .html("Size of Group");

    svg.select(".filterText")
    .append("text")
        .attr("x", 25)
        .attr("y", 35)
        .attr("font-size", "14px")
        .attr("font-family", "sans-serif")
        .html("Minimum");

        svg.select(".filterText")
  .append("text")
    .attr("x", 120)
    .attr("y", 35)
    .attr("font-size", "14px")
    .attr("font-family", "sans-serif")
    .html("Maximum");

    // Überschrift Auswahl IoUI-Koeffizient
    svg.select(".filterText")
    .append("text")
        .attr("x", 25)
        .attr("y", 85)
        .attr("font-size", "14px")
        .attr("font-family", "sans-serif")
        .html("Overlap Coefficient");

    svg.select(".filterText")
    .append("text")
        .attr("x", 25)
        .attr("y", 100)
        .attr("font-size", "14px")
        .attr("font-family", "sans-serif")
        .html("Minimum");

      svg.select(".filterText")
    .append("text")
        .attr("x", 120)
        .attr("y", 100)
        .attr("font-size", "14px")
        .attr("font-family", "sans-serif")
        .html("Maximum");

    // Überschrift Auswahl Opazität
    svg.select(".filterText")
        .append("text")
            .attr("x", 25)
            .attr("y", 150)
            .attr("font-size", "14px")
            .attr("font-family", "sans-serif")
            .html("Opacity =");

    // Zahl des Input Range Sliders
    var transparencyInputText = d3.select(".filterText")
        .append("text")
        .attr("id", "transparencyInputText")
        .attr("x", 90)
        .attr("y", 150)
        .attr("font-size", "14px")
        .attr("font-family", "sans-serif")
        .text("100");




////////////////////////
// LEGENDE

   // Finde die maximale Anzahl von Werten, die zu einem Attribut gehöhren
   var maxLengthOfAttributeValues = 0;
    const attributes = [];
    for (a in dataGroups.ATTRIBUTES) {
        // Liste aller Attribute erstellen
        attributes.push(a);
        if (dataGroups.ATTRIBUTES[a].VALUES.length > maxLengthOfAttributeValues) {
            maxLengthOfAttributeValues = dataGroups.ATTRIBUTES[a].VALUES.length;
            attributeOfMaxLengthOfAttributeValues = a;
        };
    };
    // Farben der Attribute (Rechtecke)
    var colScale = d3.scaleOrdinal()
    .range(["DodgerBlue", "DarkOrange", "ForestGreen", "FireBrick", "MediumPurple", "Sienna", "HotPink", "Silver", "YellowGreen", "Turquoise"])  // 10 Kategorien maximal
    .domain(attributes)


  // Kategorien
  var legend = svg.append("g")
    .attr("class", "attributes")
    .attr("transform", "translate(" + 0 + "," + 270 + ")")
    .selectAll("g")
    .data(attributes)
    .enter().append("g");

  // Überschrift "Attribute"
  svg.selectAll(".attributes")
  .append("text")
    .attr("x", 25)
    .attr("y", -20)
    .attr("font-size", "14px")
    .attr("font-family", "sans-serif")
    .html("Attributes");
  
  legend.append("rect")
    .attr("x", 25)
    .attr("y", function(d, i) { return (i * 15) - 9.5; })
    .attr("width", 10)
    .attr("height", 10)
    .attr("fill", function(d){return colScale(d) })
    .attr("fill-opacity", 1);

  legend.append("text")
    .attr("x", 40)
    .attr("y", function(d, i) { return i * 15; })
    .attr("font-size", "12px")
    .attr("font-family", "sans-serif")
    .html(function(d) { return d; } );

//////////


        

  // Balken für Farbverlauf des Jaccard-Koeffizienten



// Farbe der Kanten
var myColor = d3.scaleSequential().domain([1, 0])
  .interpolator(d3.interpolatePlasma);

var legend = svg.append("g")
    .attr("class", "jaccard")
    .attr("transform", "translate(" + 0 + "," + 400 + ")")

    // Achse des Balkens
    var yscale = d3.scaleLinear() 
            .domain([0, 1]) 
            .range([150, 0]); 

  // Überschrift "Jaccard"
  svg.selectAll(".jaccard")
  .append("text")
    .attr("x", 25)
    .attr("y", -20)
    .attr("font-size", "14px")
    .attr("font-family", "sans-serif")
    .html("Overlap Coefficient");


    

    svg.selectAll(".jaccard").append('g')
        .attr("id", "colorSequence")
        .attr("transform", "translate(" + 25 + "," + -10 + ")")


    function drawScale(id) {
            var data = Array.from(Array(150).keys());
            
            var cScale = d3.scaleSequential().domain([0, 150])
                .interpolator(d3.interpolatePlasma);

            var yScale = d3.scaleLinear()
                .domain([0, 150])
                .range([0, 150]);

            var u = d3.select("#" + id)
                .selectAll("rect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", 0)
                .attr("y", function(d) {
                    return Math.floor(yScale(d));
                })
                .attr("width", 50)
                .attr("height", function(d){
                    if (d == 149) {
                        return 1;
                    }
                    return Math.floor(yScale(d+1)) - Math.floor(yScale(d)) + 1;
                    
                })
                .attr("fill", function(d){
                    return cScale(d);
                });
        }

        drawScale("colorSequence");


  
    var y_axis = d3.axisRight().scale(yscale).ticks(5, "2f"); 
    
    svg.selectAll(".jaccard").append("g") 
      .attr("transform", "translate(75, -10)") 
      .call(y_axis) 





};



// ERSTELLUNG DER NETWORK VISUALISIERUNG
function createNetworkViz(dataGroups, dataGeo, targetSVG) {

    console.log("Daten der Import-Datei:", dataGroups)
      
    var width = 780;
    var height = 650;
    var spaceBetweenNodes = 10;

    var opacityUnselected = 1;
    var opacitySetting = 1;

    // Abstand des Textes von den Rechtecken
    const labelShift = 4;

    // Höhe der Rechtecke
    const rectHeight = 30;

    // Durchmesser des Kreises
    const diameter = setDiameter(width, height);
    const circumference = Math.PI * diameter;
    console.log("Kreisdurchmesser:", diameter, "Kreisumfang:", circumference);


    // Finde die maximale Anzahl von Werten, die zu einem Attribut gehöhren
    var maxLengthOfAttributeValues = 0;
    const attributes = [];
    for (a in dataGroups.ATTRIBUTES) {
        // Liste aller Attribute erstellen
        attributes.push(a);
        if (dataGroups.ATTRIBUTES[a].VALUES.length > maxLengthOfAttributeValues) {
            maxLengthOfAttributeValues = dataGroups.ATTRIBUTES[a].VALUES.length;
            attributeOfMaxLengthOfAttributeValues = a;
        };
    };
    console.log("Attribute:", attributes)
    console.log("--> Maximale Anzahl von Werten, die zu einem Attribut gehöhren:", maxLengthOfAttributeValues, "Attribut:", attributeOfMaxLengthOfAttributeValues);

    // Breite der Rechtecke, des Attributes, das die meisten Attributwerte besitzt in Pixel
    var widthForRects = (circumference/attributes.length) - (spaceBetweenNodes * dataGroups.ATTRIBUTES[attributeOfMaxLengthOfAttributeValues].VALUES.length); // Breite für alle Knoten-Rechtecke in Pixel
    console.log("--> Breite für alle Knoten-Rechtecke in Pixel:", widthForRects, "beim Attribut", attributeOfMaxLengthOfAttributeValues);

    // Skalierungsfaktor berechnen aus den Werten von dem Attribut, das die meisten Attributwerte besitzt 
    var visScale = widthForRects / dataGroups.ATTRIBUTES[attributeOfMaxLengthOfAttributeValues].COUNT;   // Maßstab/Skalierung ( Wert in Pixel / Wert )
    console.log("Skalierungsfaktor:", visScale);

    // Farben der Attribute (Rechtecke)
    var colScale = d3.scaleOrdinal()
    .range(["DodgerBlue", "DarkOrange", "ForestGreen", "FireBrick", "MediumPurple", "Sienna", "HotPink", "Silver", "YellowGreen", "Turquoise"])  // 10 Kategorien maximal
    .domain(attributes)

    // Anzahl Nutzer gesamt
    const numberOfUsers = dataGroups.USER_COUNT;
    console.log("Gesamtzahl Nutzer:", numberOfUsers);

    // Parameter der Drehung
    var rotation = 0;
    const rotationAngle = 360/attributes.length;
    const originX = width/2;
    const originY = height/2;

    ///////////////////////////////////////////
    // NODES VORBEREITEN

    attributesAndValues = {};

    for (a in dataGroups.ATTRIBUTES) {

        // Anfangsposition X für die jeweiligen Attribute
        var XPOS = width/2 - (dataGroups.ATTRIBUTES[a].COUNT * visScale + spaceBetweenNodes * dataGroups.ATTRIBUTES[a].VALUES.length)/2 + spaceBetweenNodes/2;
        console.log(a, "Anfangsposition X für die jeweiligen Attribute:", XPOS, "Umfang:", circumference, "Anzahl Attribute:", attributes.length);

        for (var g in dataGroups.GROUP_1) {
            //console.log(Object.keys(dataGroups.GROUP_1[g].ITEMS)[0]);
            if (a == Object.keys(dataGroups.GROUP_1[g].ITEMS)[0]) {
                //console.log(a, dataGroups.ATTRIBUTES[a], Object.keys(dataGroups.GROUP_1[g].ITEMS)[0], Object.values(dataGroups.GROUP_1[g].ITEMS)[0]);
                    // Parameter der Rechtecke (Nodes)
                    dataGroups.GROUP_1[g].COUNTPIX = dataGroups.GROUP_1[g]['COUNT'] * visScale; // Werte in Pixel
                    dataGroups.GROUP_1[g].ANGLE = rotation;
                    dataGroups.GROUP_1[g].ROTATION = "rotate(" + rotation + "," + originX + "," + originY + ")";
                    dataGroups.GROUP_1[g].YPOS = height/2 + diameter/2;
                    dataGroups.GROUP_1[g].XPOS = XPOS;
                    
                    // Parameter der Node-Labels
                    //var labelX = XPOS + dataGroups.GROUP_1[g]['COUNT']/2 * visScale;
                    dataGroups.GROUP_1[g].POSLABEL = {};

                    if (rotation < 0 || rotation < 180) {
                        var labelX = XPOS + dataGroups.GROUP_1[g]['COUNT']/2 * visScale + labelShift;
                        dataGroups.GROUP_1[g].POSLABEL.ANGLE = rotation - 90;
                        dataGroups.GROUP_1[g].POSLABEL.ANCHOR = "end";
                    } else {
                        var labelX = XPOS + dataGroups.GROUP_1[g]['COUNT']/2 * visScale - labelShift;
                        dataGroups.GROUP_1[g].POSLABEL.ANGLE = rotation + 90;
                        dataGroups.GROUP_1[g].POSLABEL.ANCHOR = "start";
                    };
                    
                    var labelY = height/2 + diameter/2 + rectHeight + 7;
                    var POSLABEL = rotate_point(labelX, labelY, originX, originY, rotation);
                    dataGroups.GROUP_1[g].POSLABEL.X = POSLABEL.X;
                    dataGroups.GROUP_1[g].POSLABEL.Y = POSLABEL.Y;


                    XPOS = XPOS + dataGroups.GROUP_1[g]['COUNT'] * visScale + spaceBetweenNodes;

            };
        };
        rotation = rotation + rotationAngle;
    };


    console.log(dataGroups.MAX_COMBINATION_LENGTH);

////////////////////////
// WEITERE GRUPPEN VORBEREITEN

var controlY = diameter/attributes.length;  // Verschiebung der Kontrollpunkte der Pfade/Kanten abhängig von der Anzahl dargestellter Attribute

for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
    var number = String(combinationSize);
    console.log(dataGroups["GROUP_" + number]);
    for (var g in dataGroups["GROUP_" + number]) {
        var bezierPath = [];
        for (var lpfrom = 0; lpfrom < Object.entries(dataGroups["GROUP_" + number][g]["ITEMS"]).length; lpfrom++) {
            linkPositionFrom = Object.entries(dataGroups["GROUP_" + number][g]["ITEMS"]);
            for (var npfrom in dataGroups.GROUP_1) {
                nodePositionFrom = Object.entries(dataGroups.GROUP_1[npfrom]["ITEMS"]);
                for (var lpto = lpfrom + 1; lpto < Object.entries(dataGroups["GROUP_" + number][g]["ITEMS"]).length; lpto++) {
                    linkPositionTo = Object.entries(dataGroups["GROUP_" + number][g]["ITEMS"]);
                    for (var npto in dataGroups.GROUP_1) {
                        nodePositionTo = Object.entries(dataGroups.GROUP_1[npto]["ITEMS"]);
                        if (JSON.stringify(linkPositionFrom[lpfrom]) == JSON.stringify(nodePositionFrom[0]) && JSON.stringify(linkPositionTo[lpto]) == JSON.stringify(nodePositionTo[0])) {
                            //console.log(linkPositionFrom[lpfrom], nodePositionFrom[0], linkPositionTo[lpto], nodePositionTo[0]);
                            var XPOSSOURCE = dataGroups.GROUP_1[npfrom]["XPOS"] + (dataGroups.GROUP_1[npfrom]["COUNTPIX"]/2);
                            var YPOSSOURCE = dataGroups.GROUP_1[npfrom]["YPOS"];
                            var POSSOURCE = rotate_point(XPOSSOURCE, YPOSSOURCE, originX, originY, dataGroups.GROUP_1[npfrom]["ANGLE"]);
                            var POSSOURCECONTROL = rotate_point(XPOSSOURCE, YPOSSOURCE - controlY, originX, originY, dataGroups.GROUP_1[npfrom]["ANGLE"]);
                            //console.log(rotP, rotP.x, rotP.y);
                            var XPOSTARGET = dataGroups.GROUP_1[npto]["XPOS"] + (dataGroups.GROUP_1[npto]["COUNTPIX"]/2);
                            var YPOSTARGET = dataGroups.GROUP_1[npto]["YPOS"];
                            var POSTARGET = rotate_point(XPOSTARGET, YPOSTARGET, originX, originY, dataGroups.GROUP_1[npto]["ANGLE"]);
                            var POSTARGETCONTROL = rotate_point(XPOSTARGET, YPOSTARGET - controlY, originX, originY, dataGroups.GROUP_1[npto]["ANGLE"]);

                            bezierPath.push("M", POSSOURCE.X, POSSOURCE.Y, // Moveto X- und Y-Position Start
                                      "C", POSSOURCECONTROL.X, POSSOURCECONTROL.Y, // Kontrollpunkt für die Anfangsposition
                                      POSTARGETCONTROL.X, POSTARGETCONTROL.Y, // Kontrollpunkt der Endposition
                                      POSTARGET.X, POSTARGET.Y); // Punkt, an welchem die Linie enden soll
                        };
                    };
                };
            };
        };
        dataGroups["GROUP_" + number][g].ARC = bezierPath.join(' ');
        dataGroups["GROUP_" + number][g].COUNTPIX = dataGroups["GROUP_" + number][g]['COUNT'] * visScale;
        dataGroups["GROUP_" + number][g].GRUPPE = Object.entries(dataGroups["GROUP_" + number][g]["ITEMS"]).join().replace(/,|[/]|[+]|[.]| /g, '');
        dataGroups["GROUP_" + number][g].FILTERGRUPPENGRAD = 1;
        dataGroups["GROUP_" + number][g].FILTERGRUPPENGROESSEMIN = 1;
        dataGroups["GROUP_" + number][g].FILTERGRUPPENGROESSEMAX = 1;
        dataGroups["GROUP_" + number][g].FILTERJACCARDMIN = 1;
        dataGroups["GROUP_" + number][g].FILTERJACCARDMAX = 1;
    };
};


console.log("ENDE")


// SVG
var svg = d3.select(targetSVG)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        //.append("g")


// Farbe der Kanten
var myColor = d3.scaleSequential().domain([1, 0])
  .interpolator(d3.interpolatePlasma);








//////////////////////////////////////////
// LINKS

    // Links nach "COUNT" sortieren
    linksSortedByCountSize = [];
    for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
        for (var g in dataGroups["GROUP_" + combinationSize]) {
            var gruppe = dataGroups["GROUP_" + combinationSize][g];
            console.log("gruppe", gruppe);
            linkGruppengroesse = {};
            gruppe.GRUPPENGROESSE = "GROUP_" + combinationSize;
            linksSortedByCountSize.push(gruppe)
        }
    };

    linksSortedByCountSize.sort( function ( a, b ) { return b.COUNT - a.COUNT; } );

    console.log("SORTIERTE LINKS:", linksSortedByCountSize);


    // Visualisierung der Links
    var link = svg.selectAll('mylinks')
        .data(linksSortedByCountSize)
        .enter()
        .append('path')
        .attr('class', function (d) {
                return d.GRUPPENGROESSE + " " + d.GRUPPE + " linkNotSelected";
        })
        .attr('d', function (d) {
          return d.ARC
        })
        .attr('stroke-width', function (d) { return d.COUNTPIX })
        .attr("stroke-opacity", opacityUnselected)
        .attr("fill", "none")
        .attr("stroke", function(d){ return myColor(d.IOUI) })


        // Mouseover
        .on('mouseover', function (d) {
                d3.selectAll("path.linkNotSelected") // bei Mouseover alle anderen Links mit geringerer Opazität
                    .attr('stroke-opacity', 0.05);

                if(this.classList.contains("linkNotSelected")) {
                    d3.select(this)
                        .attr('stroke', function(d){ return myColor(d.IOUI) })  // bei Mouseover den ausgewählten Link ROT anzeigen
                        .attr('stroke-opacity', opacityUnselected)
                } else {
                    d3.select(this)
                        .attr("stroke", "red")
                        .attr('stroke-opacity', opacityUnselected)
                }

                    /*
                node.attr('stroke-width', function (n) {
                    var linkAttributes = Object.entries(d.ITEMS);
                    var nodeAttributes = Object.entries(n.ITEMS);
                    for (var i = 0; i < linkAttributes.length; i++) {
                        console.log("LINK", linkAttributes, i, nodeAttributes, JSON.stringify(linkAttributes[i]), JSON.stringify(nodeAttributes[0]));
                        if (JSON.stringify(linkAttributes[i]) != JSON.stringify(nodeAttributes[0])) {
                            return 0;
                        } else {
                            return 4;
                        }
                        
                    }
                })*/

            
            })

        .on('mouseout', function (d) {
            d3.selectAll("path.linkNotSelected")
                    .attr("stroke-opacity", opacitySetting)
                    .attr("fill", "none")
                    .attr("stroke", function(d){return myColor(d.IOUI) });
                                        
                    /*
            d3.selectAll("rect.nodeNotSelected")
                .attr("stroke-width", 0)
                */


        })
        


        // Mouseclick Links
        .on("click", uplink);

            function uplink(d) {
                
                console.log("Ausgewählte Gruppe:", this);

                if(this.classList.contains("linkNotSelected")) {

                    updateTimelineSelect(d, dataGroups);
                    updateMapSelect(d, dataGroups, dataGeo);

                    // Alle Links nicht mehr selektiert
                    d3.selectAll("path.linkSelected")
                        .transition()
                        .attr("stroke", function(d){return myColor(d.IOUI) })
                        .each(function(s) {
                            this.classList.remove("linkSelected");
                            this.classList.add("linkNotSelected");
                        });

                    // Alle Nodes nicht mehr selektiert
                    d3.selectAll("rect.nodeSelected")
                        .transition()
                        .attr("stroke-width", 0)
                        .each(function(s) {
                            this.classList.remove("nodeSelected");
                            this.classList.add("nodeNotSelected");
                        });

                    // angeklickter Link als selektiert markieren
                    this.classList.remove("linkNotSelected");
                    this.classList.add("linkSelected");
                    d3.select(this).transition().attr("stroke", "red");
                }
                else {

                    updateTimelineUnselect();
                    updateMapUnselect();

                    d3.selectAll("path.linkSelected")
                        .transition()
                        .attr("stroke", function(d){return myColor(d.IOUI) })
                        .each(function(s) {
                            this.classList.remove("linkSelected");
                            this.classList.add("linkNotSelected");
                        });
                }
            };




        // Text dem Link hinzufügen, der bei Mouseover angezeigt werden soll
        link.append('title').text(function (d) {
          var groupName = "";
          for (a in d.ITEMS) {
            attributeName = (a + ": " + d.ITEMS[a] + "\n");
            groupName = groupName + attributeName;
          };
          return groupName + "\n" + 
            d.COUNT + " Users = " + (d.COUNT/numberOfUsers*100).toFixed(1) + "% of all Users" + "\n" + "\n" +
            "Overlap Coefficient: " + (d.IOUI).toFixed(2) + "\n" +
            " ↪ Reference is " + d.REFERENCE;
        });



////////////////////////
// NODES


var node = svg
    .selectAll("myrect")
    .data(dataGroups.GROUP_1)
    .enter()
    .append('rect')
    .attr("class", "GROUP_1 nodeNotSelected")
    .attr('x', function(n) {
      return n.XPOS;
    })
    .attr('y', function(n) {
      return n.YPOS;
    })
    .attr('height', rectHeight)
    .attr('width', function (n) {
      return n.COUNTPIX;
    })
    .attr('transform', function (n) {
      return n.ROTATION;
    })
    .attr("stroke", "red")
    .attr("stroke-width", 0)
    .attr("fill", function(n){return colScale(Object.keys(n.ITEMS)) })
    .attr("fill-opacity", 1)

////////////

    .on('mouseover', function (n) {

        // Nodes: Alle nicht selektierten haben keinen Rand
        d3.selectAll("rect.nodeNotSelected")
            .attr("stroke-width", 0);

        // Nodes: Alle selektierten haben einen roten Rand
        d3.select(this)
            .attr("stroke-width", 4);

        // Links: 
        for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
            for (var g in dataGroups["GROUP_" + combinationSize]) {
                var nodeAttributes = Object.entries(n.ITEMS).join().replace(/,|[/]|[+]|[.]| /g, '');
                var linkAttributes = dataGroups["GROUP_" + combinationSize][g]["GRUPPE"]; // Object.entries(dataGroups["GROUP_" + combinationSize][g]["ITEMS"]).join().replace(/,|[/]|[+]|[.]| /g, '');

                if (linkAttributes.includes(nodeAttributes)) {
                    //console.log("NODES", nodeAttributes, "LINKS", linkAttributes);
                    d3.selectAll("path." + linkAttributes)
                        .each(function(s) {
                            if(this.classList.contains("linkSelected")) {
                                d3.select(this).attr('stroke', "red");
                            } else {
                                d3.select(this).attr('stroke', function(d){return myColor(d.IOUI)});
                            }
                        })
                } else {
                    d3.selectAll("path." + linkAttributes)
                    .each(function(s) {
                            if(this.classList.contains("linkSelected")) {
                                d3.select(this).attr('stroke', "red");
                            } else {
                                d3.select(this).attr('stroke-opacity', 0);
                            }
                    })
                }
            }
        }
    })

      /////////////////
      
    .on('mouseout', function (n) {

        // Nodes: Alle nicht selektierten haben keinen Rand
        d3.selectAll("rect.nodeNotSelected")
            .attr("stroke-width", 0)

        for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                d3.selectAll("path.GROUP_" + combinationSize).filter(".linkNotSelected")
                    .attr("stroke-opacity", opacitySetting)
                    .attr("fill", "none")
                    .attr("stroke", function(d){return myColor(d.IOUI)});
          };

    })

    // Mouseclick Nodes
    .on("click", upnode);

    function upnode(d) {
        
        console.log("Ausgewählte Gruppe:", this);

        if(this.classList.contains("nodeNotSelected")) {

            updateTimelineSelect(d, dataGroups);
            updateMapSelect(d, dataGroups, dataGeo);

            // Alle Nodes nicht mehr selektiert
            d3.selectAll("rect.nodeSelected")
                .transition()
                .attr("stroke-width", 0)
                .each(function(s) {
                    this.classList.remove("nodeSelected");
                    this.classList.add("nodeNotSelected");
                });

            // Alle Links nicht mehr selektiert
            d3.selectAll("path.linkSelected")
                .transition()
                .attr("stroke", function(d){return myColor(d.IOUI) })
                .each(function(s) {
                    this.classList.remove("linkSelected");
                    this.classList.add("linkNotSelected");
                });

            // angeklickter Node als selektiert markieren
            this.classList.remove("nodeNotSelected");
            this.classList.add("nodeSelected");
            d3.select(this).transition().attr("stroke-width", 4);
        }
        else {

            updateTimelineUnselect();
            updateMapUnselect();

            d3.selectAll("rect.nodeSelected")
                .transition()
                .attr("stroke-width", 0)
                .each(function(s) {
                    this.classList.remove("nodeSelected");
                    this.classList.add("nodeNotSelected");
                });
        }
    };
 
    // Text dem Nodes hinzufügen, der bei Mouseover angezeigt werden soll
    node.append('title').text(function (n) { return Object.keys(n.ITEMS) + ": " + Object.values(n.ITEMS) + "\n" + n.COUNT + " Users = " + (n.COUNT/numberOfUsers*100).toFixed(1) + "% of all Users"});



////////////////////////////////////////////
// NODE LABELS

    
  var labels = svg
    .selectAll("mylabels")
    .data(dataGroups.GROUP_1)
    .enter()
    .append("text")
    .attr("transform", function(d)  {
        return "translate(" + d.POSLABEL.X + " , " + d.POSLABEL.Y + ") rotate(" + d.POSLABEL.ANGLE + ")";
        })
    .attr("font-family", "sans-serif")
    .attr("font-size", "10px")
    .attr("fill", "black")
    .attr("text-anchor", function(d) {
        return d.POSLABEL.ANCHOR })
    .text(function(d){ return(Object.values(d.ITEMS))})

    //.attr("text-anchor", "start")





//////////////////////////////////////////
// DROP-DOWN-MENÜ


svg.append("g")
        .attr("class", "filterText")
        .attr("transform", "translate(" + 0 + "," + 40 + ")")



    // Inhalt
    var dataKeys = ["All Groups"];

    for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
        dataKeys.push("Groups with " + combinationSize + " Attributes")
    };
    console.log("Auswahlmöglichkeiten im Drop-Down-Menü:", dataKeys);

    d3.select("#controls")
        .append("select")
        .attr("id", "attributeSizeSelector")
        .style("position", "absolute")
        .style("left", "25px")
        .style("top", "15px")
        .selectAll("option")
        .data(dataKeys)
        .enter()
        .append("option")
        .text(function(d) { return d; })
		    .attr("value", function (d, i) {
			      return i + 1;
        });


    d3.select("#attributeSizeSelector")
	      .on("change", function(d) {
                index = this.value;
                console.log("Auswahl Gruppengrad:", index);
            
        for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
            for (var g in dataGroups["GROUP_" + combinationSize]) {

                if (index >= 2 && index == combinationSize) {
                    dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] = 1;
                } else {
                    dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] = 0;
                };

                if (index == "1") {
                    dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] = 1;
                };
            };    
        };

        for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
            for (var g in dataGroups["GROUP_" + combinationSize]) {

                    if (dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] == 1) {

                    var linkSize = dataGroups["GROUP_" + combinationSize][g]["COUNTPIX"]
                    d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                        .transition()
                        .duration(1000)
                        .attr('stroke-width', linkSize);
                } else {
                    var linkSize = 0
                    d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                        .transition()
                        .duration(1000)
                        .attr('stroke-width', linkSize);
                };
            };

        };

    });





//////////////////////////////////////////
// FELD FÜR KANTENGRÖSSE (MINIMUM)


    // Inputfeld Minimum
    d3.select("#controls")
        .append("input")
        .attr("id", "linkSizeInputMin")
        .attr("class", "linkSizeInput")
        .style("position", "absolute")
        .style("left", "25px")
        .style("top", "80px")
        .style("width", "80px")
        .attr("type", "number")
        .attr("value", 1)
        .attr("min", 1)
        .attr("max", dataGroups.USER_COUNT);



    d3.select("#linkSizeInputMin")
        .on("input", function (d) {
            linkSizeMin = this.value;
            console.log("Auswahl Gruppengröße Minimum:", linkSizeMin);

            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {
                    
                    if (dataGroups["GROUP_" + combinationSize][g]["COUNT"] >= linkSizeMin) {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] = 1;
                    } else {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] = 0;
                    };
                };    
            };

            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {

                    if (dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] == 1) {

                        var linkSize = dataGroups["GROUP_" + combinationSize][g]["COUNTPIX"]
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    } else {
                        var linkSize = 0
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    };

                };

            };


        });




    //////////////////////////////////////////
    // FELD FÜR KANTENGRÖSSE (MAXIMUM)



    d3.select("#controls")
        .append("input")
        .attr("id", "linkSizeInputMax")
        .attr("class", "linkSizeInput")
        .style("position", "absolute")
        .style("left", "120px")
        .style("top", "80px")
        .style("width", "80px")
        .attr("type", "number")
        .attr("value", dataGroups.USER_COUNT)
        .attr("min", 1)
        .attr("max", dataGroups.USER_COUNT);


    d3.select("#linkSizeInputMax")
        .on("input", function (d) {
            linkSizeMax = this.value;
            console.log("Auswahl Gruppengröße Maximum:", linkSizeMax);


            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {
                    
                    if (dataGroups["GROUP_" + combinationSize][g]["COUNT"] <= linkSizeMax) {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] = 1;
                    } else {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] = 0;
                    };
                };    
            };

            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {

                    if (dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] == 1) {

                        var linkSize = dataGroups["GROUP_" + combinationSize][g]["COUNTPIX"]
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    } else {
                        var linkSize = 0
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    };

                };

            };


    });









//////////////////////////////////////////
// FELD FÜR JACCARD-KOEFFIZIENT (MINIMUM)



    // Inputfeld Minimum
    d3.select("#controls")
        .append("input")
        .attr("id", "jaccardInputMin")
        .attr("class", "jaccardInput")
        .style("position", "absolute")
        .style("left", "25px")
        .style("top", "145px")
        .style("width", "80px")
        .attr("type", "number")
        .attr("value", 0.0)
        .attr("step", 0.01)
        .attr("min", 0.0)
        .attr("max", 1.0);
        


    d3.select("#jaccardInputMin")
        .on("input", function (d) {
            jaccardMin = this.value;
            console.log("Auswahl Jaccard Minimum:", jaccardMin);

            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {
                    
                    if (dataGroups["GROUP_" + combinationSize][g]["IOUI"] >= jaccardMin) {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] = 1;
                    } else {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] = 0;
                    };
                };    
            };

            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {

                    if (dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] == 1) {

                        var linkSize = dataGroups["GROUP_" + combinationSize][g]["COUNTPIX"]
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    } else {
                        var linkSize = 0
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    };

                };

            };


        });




    //////////////////////////////////////////
    // FELD FÜR JACCARD-KOEFFIZIENT (MAXIMUM)


    d3.select("#controls")
        .append("input")
        .attr("id", "jaccardInputMax")
        .attr("class", "jaccardInput")
        .style("position", "absolute")
        .style("left", "120px")
        .style("top", "145px")
        .style("width", "80px")
        .attr("type", "number")
        .attr("value", 1.0)
        .attr("step", 0.01)
        .attr("min", 0.0)
        .attr("max", 1.0);


    d3.select("#jaccardInputMax")
        .on("input", function (d) {
            jaccardMax = this.value;
            console.log("Auswahl Jaccard Maximum:", jaccardMax);


            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {
                    
                    if (dataGroups["GROUP_" + combinationSize][g]["IOUI"] <= jaccardMax) {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] = 1;
                    } else {
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] = 0;
                    };
                };    
            };

            for (var combinationSize = 2; combinationSize <= dataGroups.MAX_COMBINATION_LENGTH; combinationSize++) {
                for (var g in dataGroups["GROUP_" + combinationSize]) {

                    if (dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGRAD"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERGRUPPENGROESSEMAX"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMIN"] == 1 &&
                        dataGroups["GROUP_" + combinationSize][g]["FILTERJACCARDMAX"] == 1) {

                        var linkSize = dataGroups["GROUP_" + combinationSize][g]["COUNTPIX"]
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    } else {
                        var linkSize = 0
                        d3.selectAll("path." + dataGroups["GROUP_" + combinationSize][g]["GRUPPE"])
                            .transition()
                            .duration(1000)
                            .attr('stroke-width', linkSize);
                    };

                };

            };


    });



    //////////////////////////////////////////
    // INPUT RANGE SLIDER FÜR TRANSPARENZ


    // Input Range Slider
    d3.select("#controls")
        .append("input")
        .attr("id", "transparencyInput")
        .style("position", "absolute")
        .style("left", "23px")
        .style("top", "190px")
        .style("width", "183px")
        .attr("type", "range")
        .attr("value", 100)
        .attr("step", 1)
        .attr("min", 0)
        .attr("max", 100);



    // when the input range changes update the circle 
    d3.select("#transparencyInput").on("input", function() {
        updateTransparancy(this.value);
        opacitySetting = this.value/100;
        console.log("opacitySetting", opacitySetting);
    });

    // update the elements
    function updateTransparancy(transparencyInput) {

        // adjust the text on the range slider
        d3.select("#transparencyInputText").text(transparencyInput);

        // update Colorsequence des Jaccard-Koeffizient in der Legende
        d3.select("#colorSequence")
            .attr('opacity', transparencyInput/100);

        d3.selectAll(".linkNotSelected")
            .attr('stroke-opacity', transparencyInput/100);
    }










};



















////////////////////////////////////////
// ERSTELLUNG DER TIME VISUALISIERUNG //
////////////////////////////////////////
function createTimeViz(dataGroups, targetSVG) {
    
    console.log("Datenimport in Time Visualisierung:", dataGroups);

    const attributes = dataGroups.ATTRIBUTES;
    console.log("Datenimport in Time Visualisierung:", attributes);

    maxCount = 0;
    for (var combinationSize = 1; combinationSize <= attributes.length; combinationSize++) {
        var number = String(combinationSize);
        // console.log(dataGroups["GROUP_" + number]);
        for (var g in dataGroups["GROUP_" + number]) {
            for (var item in dataGroups["GROUP_" + number][g]["TIMESTAMPS"]) {
                if (dataGroups["GROUP_" + number][g]["TIMESTAMPS"][item]["COUNT"] > maxCount) {
                    maxCount = dataGroups["GROUP_" + number][g]["TIMESTAMPS"][item]["COUNT"];
                }
            }
        }
    };
  
    console.log("maxCount:", maxCount);

    var dates = dataGroups["GROUP_1"][0]["TIMESTAMPS"].map(function(d) { return d.DATE; });
    console.log("DATES:", dates);



    // set the dimensions and margins of the graph
    var margin = {top: 20, right: 20, bottom: 70, left: 60},
        width = 1000 - margin.left - margin.right,
        height = 250 - margin.top - margin.bottom;
  

    



    
    // Establish the desired formatting options using locale.format():
    var formatMillisecond = d3.timeFormat(".%L"),
        formatSecond = d3.timeFormat(":%S"),
        formatMinute = d3.timeFormat("%I:%M"),
        formatHour = d3.timeFormat("%I %p"),
        formatDay = d3.timeFormat("%a %d"),
        formatWeek = d3.timeFormat("%b %d"),
        formatMonth = d3.timeFormat("%B"),
        formatYear = d3.timeFormat("%Y");

    // Define filter conditions
    function multiFormat(date) {
      return (d3.timeSecond(date) < date ? formatMillisecond
        : d3.timeMinute(date) < date ? formatSecond
        : d3.timeHour(date) < date ? formatMinute
        : d3.timeDay(date) < date ? formatHour
        : d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? formatDay : formatWeek)
        : d3.timeYear(date) < date ? formatMonth
        : formatYear)(date);
    };




    // Datum Eingabe
    var parseTime = d3.timeParse("%Y-%m-%d");       // Datum als Jahr, Monat, Tag
    //var parseTime = d3.timeParse("%H:%M:%S");       // Datum als Stunde, Minute, Sekunde


    datesDate = [];
    // format the data
    for (item in dates) {
      datesDate.push(parseTime(dates[item]));
    };

    console.log("DATES:", datesDate);

    datesDateDomain = d3.extent(datesDate); // berechnet min und max



    var x = d3.scaleTime()
        .domain(datesDateDomain, 1)
        //.range([0, width]);
        .range([(width/dates.length)/2, width - (width/dates.length)/2]);


    // Use the custom scale
    var xAxis = d3.axisBottom()
        .scale(x)
        .tickFormat(multiFormat);




    var y = d3.scaleLinear()
                  .range([height, 0])
                  .domain([0, maxCount]);


    var yAxis = d3.axisLeft(y)
          //.orient("left")
          .ticks(10);


        
    // SVG
    var svg = d3.select(targetSVG)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");
    


    // add the Y gridlines
    svg.append("g")			
        .attr("class", "grid")
        .call(d3.axisLeft(y)
            .ticks(5)
            .tickSize(-width)
            .tickFormat("")
        );

  
    // add X axis

    svg.append("g")
      .attr("class", "xaxis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);



    // add Y axis
    svg.append("g")
      .attr("class", "yaxis")
      .call(yAxis)
      .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 5)
      .attr("dy", ".71em")
      .style("text-anchor", "end");


    // text label for the x axis
    svg.append("g")
        .attr("class", "x label")
        .append("text")             
        .attr("transform",
              "translate(" + (width/2) + " ," + 
                            (height + margin.top + 10) + ")")
        .style("text-anchor", "middle")
        .text("Date of creation of the user account");



    // text label for the y axis
    svg.append("g")
        .attr("class", "y label").
        append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Number of Users");


    // Add bars
        svg.append("g")
        .attr("class", "bar")
          .selectAll("rect")
          .data(dataGroups["GROUP_1"][0]["TIMESTAMPS"])
          .enter()
          .append("rect")
          .attr("width", 0) //x.bandwidth() )
          .attr("height", function(d) {return height - y(d.COUNT);})
          .attr("x", function(d) {return x(parseTime(d.DATE)); })
          .attr("y", function(d) {return y(d.COUNT);})
          .append("title");
        
    // add g für text gruppen
          svg.append("g")
        .attr("id","grouptime")

  
  };
  
  /////////////////////////////////
  // Aktualisierung der Timeline //
  /////////////////////////////////

  // AKTUALISIERUNG WENN GRUPPE SELEKTIERT IST
  function updateTimelineSelect(group, dataGroups) {


      console.log("Ausgewählte Gruppe:", group);

      const formatDate = d3.timeFormat("%Y %B");
      
      timestamps = [];
      for (ts in group["TIMESTAMPS"]) {
          //console.log(group["TIMESTAMPS"][ts]);
          tsItem = {};
          tsItem.DATE = group["TIMESTAMPS"][ts]["DATE"];
          tsItem.COUNT = group["TIMESTAMPS"][ts]["COUNT"];
          timestamps.push(tsItem);
      };
      console.log("Neue Timestamps:", timestamps);
  
  
      var margin = {top: 20, right: 20, bottom: 70, left: 60},
          width = 1000 - margin.left - margin.right,
          height = 250 - margin.top - margin.bottom;
  
    
      var x = d3.scaleBand()
                  .range([0, width], .05)
                  .domain(timestamps.map(function(d) { return d.DATE; }));

      /*
      var xAxis = d3.axisBottom(x)
          //.orient("bottom")
          //.tickFormat(d3.timeFormat("%Y-%m-%d"));
      */

      var y = d3.scaleLinear()
                  .range([height, 0])
                  .domain([0, d3.max(group["TIMESTAMPS"], function(d) { return d.COUNT; })]);
  
  
      var yAxis = d3.axisLeft(y)
          .ticks(10);
  
      // GRUPPENNAMEN ANZEIGEN
      var textGroup = d3.select("#grouptime");
      var plot = d3.select("#time_viz");
  

        groupName = [];
        for (item in group.ITEMS) {
          //console.log(item, group.ITEMS[item])
          itemString = item + ":" + " " + group.ITEMS[item];
          //console.log(itemString);
          groupName.push(itemString);
        };
        //console.log(groupName);


        // Text Gruppenname aktualisieren
        textGroup.selectAll("text")     
                .remove();

        textGroup.selectAll("text")
              .data(groupName)
              .enter()
              .append("text")
              .attr("x", 10)
              .attr("y", function(d, i) { 
                      return i * 15 + 10;
                      })
              .attr("font-size", "12px")
              .attr("font-family", "sans-serif")
              .text(groupName)
              .text(function(d) { 
                      return d; 
                      });

        // Y-Achse aktualisieren
        plot.selectAll("g.yaxis")
              .transition()
              .duration(750)
              .call(yAxis);
              
        // Grid der Y.Achse aktualisieren
        plot.selectAll("g.grid")			
              .transition()
              .duration(750)
              .call(d3.axisLeft(y)
                  .ticks(5)
                  .tickSize(-width)
                  .tickFormat("")
              )

        // Rechtecke aktualisieren
        plot.selectAll("rect")
            .data(timestamps)
            .transition()
            .duration(750)
            .attr("width", x.bandwidth() )
            .attr("height", function(d) {return height - y(d.COUNT);})
            .attr("x", function(d) {return x(d.DATE); })
            .attr("y", function(d) {return y(d.COUNT);});

        // Text bei Maus-Hover der Rechtecke aktualisieren
        plot.selectAll("title")
                .data(timestamps)
                .text(function(d) {
                  //console.log("TITLE:", d)
                  return formatDate(new Date(d.DATE)) + "\n" +  d.COUNT + " Users = " + (d.COUNT/dataGroups.USER_COUNT*100).toFixed(1) + "% of all Users";
                });

  };
  

    // AKTUALISIERUNG WENN GRUPPE NICHT MEHR SELEKTIERT IST
    function updateTimelineUnselect(group) {
        // GRUPPENNAMEN LÖSCHEN
        var textGroup = d3.select("#grouptime");
        textGroup.selectAll("text")     
                .remove();

        // RECHTECKE LÖSCHEN
        var plot = d3.select("#time_viz");
        plot.selectAll("rect")
            .transition()
            .duration(750)
            .attr("width", 0)
            .attr("height", 0)
    };

/////////////////////////////////////////
// ERSTELLUNG DER SPACE VISUALISIERUNG //
/////////////////////////////////////////
function createSpaceViz(dataGroups, dataGeo, targetSVG) {

    console.log("Datenimport in Space Visualisierung: GROUPS:", dataGroups);
    console.log("Datenimport in Space Visualisierung: GEO:", dataGeo);

    // set the dimensions and margins of the graph
    var margin = {top: 0, right: 0, bottom: 0, left: 0},
        width = 700 - margin.left - margin.right,
        height = 900 - margin.top - margin.bottom;

    // SVG
    var svg = d3.select(targetSVG)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);
          //.append("g")
          //.attr("transform", 
          //    "translate(" + margin.left + "," + margin.top + ")");



    // Map and projection
    var projection = d3.geoMercator()
        .center([10.4477, 51.1633])                // GPS of location to zoom on
        .scale(3600)                       // This is like the zoom
        .translate([ width/2, height/2 ])


 
    // Draw the map
    svg.append("g")
            .attr("class", "map")
        .selectAll("path")
        .data(dataGeo.features)
        .enter()
        .append("path")
            .attr("fill", "#b8b8b8")
            .attr("d", d3.geoPath()
                .projection(projection)
            )
        .style("stroke", "white")
        .style("opacity", .3)


        // console.log("GEO TEST:", dataGeo.features[14].geometry.coordinates[0][0]);


    // Draw the bubbles



        selectedGroup = dataGroups.GROUP_1[0]

        //console.log("Ausgewählte Gruppe:", selectedGroup);

        for (locIDGroup in selectedGroup["LOCATIONS"]) {
            for (locIDCoord in dataGroups["LOCATIONS"]) {
                if (selectedGroup["LOCATIONS"][locIDGroup]["ID"] == dataGroups["LOCATIONS"][locIDCoord]["ID"]) {
                    //console.log(selectedGroup["LOCATIONS"][locIDGroup]["ID"], dataGroups["LOCATIONS"][locIDCoord]["ID"], dataGroups["LOCATIONS"][locIDCoord]["NAME"]);
                    selectedGroup["LOCATIONS"][locIDGroup]["NAME"] = dataGroups["LOCATIONS"][locIDCoord]["NAME"];
                    selectedGroup["LOCATIONS"][locIDGroup]["X"] = parseFloat(dataGroups["LOCATIONS"][locIDCoord]["X"].replace(",", "."));
                    selectedGroup["LOCATIONS"][locIDGroup]["Y"] = parseFloat(dataGroups["LOCATIONS"][locIDCoord]["Y"].replace(",", "."));

                }
            }
        }



        svg.append("g")
        .attr("class", "bubble")
      .selectAll("circle")
        .data(selectedGroup.LOCATIONS) //.sort(function(a,b) { return +b.COUNT - +a.COUNT }))
      .enter().append("circle")
        .attr("cx", function(d){ return projection([+d.X, +d.Y])[0] })
        .attr("cy", function(d){ return projection([+d.X, +d.Y])[1] })
        .attr("r", 0) //function(d){ return size(+d.COUNT) })
      .append("title")
      .text(function(d) {
                  //console.log("TITLE:", d)
                  return d.NAME;
                });




        // Titel der Karte
        svg.append("text")
        .attr("x", 350) // Horizontale Position (zentriert)
        .attr("y", 25)  // Vertikale Position
        .attr("text-anchor", "middle") // Textausrichtung
        .style("font-family", "sans-serif") // Schriftart
        .style("font-size", "12px") // Schriftgröße
        .style("font-weight", "bold") // Fettschrift
        .text("Constituencies of Germany");

        // Legende

        var max = d3.max(selectedGroup.LOCATIONS, function(d) { return +d.COUNT; });

        var radius = d3.scaleSqrt()
          .domain([0, max])
          .range([0, 25]);



        var legend = svg.append("g")
          .attr("class", "legend")
          .attr("transform", "translate(" + (70) + "," + (height - 80) + ")")
        .selectAll("g")
          .data([1, max])
        .enter().append("g");


        legend.append("circle")
          .attr("class", "legend")
          .attr("cy", function(d) { return -radius(d); })
          .attr("r", radius);

            // Add legend: segments
        legend.append("line")
            .attr("class", "legend")
            .attr("x1", function(d) { return; })
            .attr("y1", function(d) { return -2 * radius(d); })
            .attr("x2", function(d) { return + 30; })
            .attr("y2", function(d) { return -2 * radius(d); })

        legend.append("text")
          .attr("class", "legend")
          .attr("x", function(d) { return + 35; })
          .attr("y", function(d) { return -2 * radius(d) - 5; })
          .attr("dy", "0.9em")
          .text(d3.format(","));

        // Text Legende
        svg.select("g.legend")
          .attr("class", "legend")
          .append("text")
          .attr("x", -25)
          .attr("y", -65)
          .style("text-anchor", "left")
          .text("Number of Users");

        // add g für text gruppen
        svg.append("g")
          .attr("id","groupspace")

};

        /////////////////////////////////
        // Aktualisierung der Karte //
        /////////////////////////////////

    // AKTUALISIERUNG WENN GRUPPE SELEKTIERT IST
    function updateMapSelect(group, dataGroups, dataGeo) {
        

        console.log("Ausgewählte Gruppe:", group);
        console.log("Ausgewählte Gruppe:", dataGroups);

        for (locIDGroup in group["LOCATIONS"]) {
            for (locIDCoord in dataGroups["LOCATIONS"]) {
                if (group["LOCATIONS"][locIDGroup]["ID"] == dataGroups["LOCATIONS"][locIDCoord]["ID"]) {
                    //console.log(selectedGroup["LOCATIONS"][locIDGroup]["ID"], dataGroups["LOCATIONS"][locIDCoord]["ID"], dataGroups["LOCATIONS"][locIDCoord]["NAME"]);
                    group["LOCATIONS"][locIDGroup]["NAME"] = dataGroups["LOCATIONS"][locIDCoord]["NAME"];
                    group["LOCATIONS"][locIDGroup]["X"] = parseFloat(dataGroups["LOCATIONS"][locIDCoord]["X"].replace(",", "."));
                    group["LOCATIONS"][locIDGroup]["Y"] = parseFloat(dataGroups["LOCATIONS"][locIDCoord]["Y"].replace(",", "."));

                }
            }
        }


        // set the dimensions and margins of the graph
        var margin = {top: 0, right: 0, bottom: 0, left: 0},
            width = 700 - margin.left - margin.right,
            height = 900 - margin.top - margin.bottom;



        // Map and projection
        var projection = d3.geoMercator()
            .center([10.4477, 51.1633])                // location to zoom on
            .scale(3600)                       // This is like the zoom
            .translate([ width/2, height/2 ])
    
    
        var max = d3.max(group.LOCATIONS, function(d) { return + d.COUNT; });

        var size = d3.scaleSqrt()
          .domain([0, max])  // What's in the data
          .range([0, 25])  // Size in pixel



        var plot = d3.select("#space_viz");

        plot.selectAll("circle")
            .data(group.LOCATIONS) //.sort(function(a,b) { return +b.COUNT - +a.COUNT }))
            .transition()
            .duration(750)
            .attr("class", "map")
            .attr("cx", function(d){ return projection([+d.X, +d.Y])[0] })
            .attr("cy", function(d){ return projection([+d.X, +d.Y])[1] })
            .attr("r", function(d){ 
                //console.log(d);
                return size(+d.COUNT) })


        // Text bei Maus-Hover der Kreise aktualisieren
        plot.selectAll("title")
                .data(group.LOCATIONS) //.sort(function(a,b) { return +b.COUNT - +a.COUNT }))
                .text(function(d) {
                  //console.log("TITLE:", d)
                  return d.NAME + "\n" +  d.COUNT + " Users = " + (d.COUNT/dataGroups.USER_COUNT*100).toFixed(1) + "% of all Users";
                });

        // Legende


        var radius = d3.scaleSqrt()
          .domain([0, max])
          .range([0, 25]);

          


        plot.selectAll("circle.legend")
          .data([1, max])
          .transition()
          .duration(750)
          .attr("cy", function(d) { return -radius(d); })
          .attr("r", radius);

            // Add legend: segments
        plot.selectAll("line.legend")
          .data([1, max])
          .transition()
            .duration(750)
            .attr("x1", function(d) { return; })
            .attr("y1", function(d) { return -2 * radius(d); })
            .attr("x2", function(d) { return + 30; })
            .attr("y2", function(d) { return -2 * radius(d); })

        plot.selectAll("text.legend")
          .data([1, max])
          .transition()
            .duration(750)
          .attr("x", function(d) { return + 35; })
          .attr("y", function(d) { return -2 * radius(d) - 5; })
          .attr("dy", "0.9em")
          .text(d3.format(","));

        // GRUPPENNAMEN ANZEIGEN
        var textGroup = d3.select("#groupspace");

        groupName = [];
        for (item in group.ITEMS) {
          //console.log(item, group.ITEMS[item])
          itemString = item + ":" + " " + group.ITEMS[item];
          //console.log(itemString);
          groupName.push(itemString);
        };
        //console.log(groupName);


        // Text Gruppenname aktualisieren
        textGroup.selectAll("text")     
                .remove();

        textGroup.selectAll("text")
              .data(groupName)
              .enter()
              .append("text")
              .attr("x", 45)
              .attr("y", function(d, i) { 
                      return i * 15 + 25;
                      })
              .attr("font-size", "12px")
              .attr("font-family", "sans-serif")
              .text(groupName)
              .text(function(d) { 
                      return d; 
                      });



    };

    // AKTUALISIERUNG WENN GRUPPE NICHT MEHR SELEKTIERT IST
    function updateMapUnselect(group, dataGroups, dataGeo) {
        // GRUPPENNAMEN LÖSCHEN
        var textGroup = d3.select("#groupspace");
        textGroup.selectAll("text")     
                .remove();

        // KREISE LÖSCHEN
        var plot = d3.select("#space_viz");

        plot.selectAll("circle.map")
            .transition()
            .duration(750)
            .attr("r", 0)
    }




</script>

